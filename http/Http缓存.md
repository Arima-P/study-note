# HTTP 缓存

## 强缓存

### 关联字段

- Expires，1.0
- Cache-Control，1.1

### 两种情况

- 需要发送 HTTP 请求
- 不需要发送 HTTP 请求

### Expires

HTTP1.0 版本中，使用 Expires，即过期时间，这个时间相对于服务器时间，存在于响应头中，在这个过期时间之前可以从缓存中获取数据，无需再请求

#### 存在的问题

服务器时间与客户端时间可能不一致

### Cache-Control

HTTP1.1 版本中，使用 Cache-Control ，代表过期时长，对应的是 max-age

```
Cache-Control:max-age=6000
```

### 注意点

- Expires 和 Cache-Control 同时存在，优先考虑 Cache-Control
- 当没有命中强缓存时，进入协商缓存

## 协商缓存

当强缓存失效后，浏览器在请求头中携带响应的**缓存 Tag**向服务器发送请求，服务器根据对应的 tag，来决定是否使用缓存

缓存分为两种 `Last-Modified` 和 `ETag`

### `Last-Modified`

表示：**最后的修改时间**，在浏览器第一次向服务器发送请求后，服务器会在响应头中加上这个字段

浏览器接收到后，如果*再次请求*，会在请求头中携带 `If-Modified-Since` 字段，这个值就是服务器传来的最后修改时间。

服务端拿到 `If-Modified-Since` 后，与服务器中该资源得最后修改时间对比

- 如果请求头的值小于最后修改时间，说明更新了，返回新的资源，与常规 HTTP 请求响应一致
- 否则返回 304，告诉浏览器使用缓存

### `ETag`

`ETag` 是服务器根据当前文件内容，给文件生成得唯一标识，比如 MD5 算法，只要里面得内容有改动，这个值就会发生变化

浏览器接收到 `ETag` 后，如果*再次请求*，会将这个值作为 `If-None-Match` 这个字段得内容，发送给服务器

服务器接收到 `If-None-Match` 后，会跟服务器上得 `ETag` 进行比较

- 如果两者一样，则返回 304，告诉浏览器使用缓存
- 如果不一样，返回新的资源，跟常规请求响应流程一样

### 对比

- 性能上，`Last-Modified` 优于 `ETag` ，因为 `Last-Modified` 只是记录一个时间点，而 `ETag` 需要根据 MD5 算法计算每个问题得 hash
- 精度上，`ETag` 优于 `Last-Modified`。`ETag` 能准确感知 资源变化，而 `Last-Modified` 不太灵敏
  - 编辑了资源文件，内容没有发生变化，也会导致缓存失效
  - `Last-Modified` 感知得单位时间为秒，如果文件在 1 秒内变化多次，那么 `Last-Modified` 就不能体现出修改
- 如果服务器两者都支持，会优先考虑 `ETag`

## 缓存位置

从优先级高到低排序

- Service Worker，这个应用场景比如 PWA，它借鉴了 Web Worker 思路，由于它脱离了浏览器的窗体，因此无法直接访问 DOM。它能完成的功能比如：离线缓存、消息推送和网络代理，其中离线缓存就是「Service Worker Cache」。
- Memory Cache，指的是内存缓存，从效率上讲它是最快的，从存活时间来讲又是最短的，当渲染进程结束后，内存缓存也就不存在了。
- Disk Cache，存储在磁盘中的缓存，从存取效率上讲是比内存缓存慢的，优势在于存储容量和存储时长。
- Push Cache，推送缓存，这算是浏览器中最后一道防线吧，它是 HTTP/2 的内容

**Disk Cache VS Memory Cache**

两者对比，主要的策略 👇

- 内容使用率高的话，文件优先进入磁盘
- 比较大的 JS，CSS 文件会直接放入磁盘，反之放入内存。
